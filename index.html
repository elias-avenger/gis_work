<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Within Checker</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #f7f7f7;
            padding: 40px;
            margin: 0;
        }
        h2 {
            color: #222;
            margin-bottom: 24px;
        }
        .import-section {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
            padding: 24px 28px 18px 28px;
            margin-bottom: 28px;
            max-width: 600px;
        }
        label {
            font-weight: 600;
            color: #444;
        }
        input[type="file"], select {
            padding: 8px 10px;
            border-radius: 4px;
            border: 1px solid #bbb;
            margin-top: 6px;
            margin-bottom: 10px;
            font-size: 1em;
        }
        input[type="file"]::-webkit-file-upload-button {
            background: #eee;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
        }
        #polygonBoundaryStatus, #featuresFileStatus {
            color: #006400;
            font-size: 1em;
            margin-top: 10px;
            min-height: 24px;
        }
        #featuresCSVColumnSelector label {
            font-weight: 500;
        }
        #featuresCSVColumnSelector select {
            min-width: 180px;
        }
        #featuresCSVColumnSelector button {
            background: #0078d4;
            color: #fff;
            border: none;
            border-radius: 4px;
            padding: 7px 16px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.2s;
        }
        #featuresCSVColumnSelector button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        #featuresCSVColumnSelector button:not(:disabled):hover {
            background: #005fa3;
        }
        #compareBtn {
            padding: 12px 28px;
            font-size: 1.1em;
            background: #0078d4;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            transition: background 0.2s;
        }
        #compareBtn:disabled {
            background: #ccc;
            color: #888;
            cursor: not-allowed;
        }
        #compareBtn:not(:disabled):hover {
            background: #005fa3;
        }
        #compareResults {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
            padding: 22px 28px;
            margin-top: 18px;
            max-width: 600px;
            font-size: 1.08em;
        }
        details {
            margin-top: 10px;
        }
        summary {
            cursor: pointer;
            font-weight: 500;
        }
        ol {
            margin: 0 0 0 18px;
        }
        .export-buttons {
            margin-top: 12px;
            margin-bottom: 16px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .export-btn {
            background: #0078d4;
            color: #fff;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background 0.2s;
        }
        .export-btn:hover {
            background: #005fa3;
        }
    </style>
</head>
<body>
    <h2>Check whether features are contained within a polygon boundary</h2>
    <div class="import-section">
        <label for="polygonBoundaryInput">Polygon Boundary (GeoJSON):</label><br>
        <input type="file" id="polygonBoundaryInput" accept="application/geo+json,application/json,.geojson,.json" />
        <div id="polygonBoundaryStatus"></div>
    </div>
    <div class="import-section">
        <label for="featuresFileInput">Features File (CSV or GeoJSON):</label>
        <select id="featuresFileTypeSelect" style="margin-left:10px;">
            <option value="csv">CSV</option>
            <option value="geojson">GeoJSON</option>
        </select>
        <input type="file" id="featuresFileInput" accept="application/geo+json,application/json,.geojson,.json,.csv,text/csv" />
        <div id="featuresCSVColumnSelector"></div>
        <div id="featuresFileStatus"></div>
    </div>
    <div class="import-section" style="text-align:center;">
        <button id="compareBtn" disabled>Compare Features</button>
    </div>
    <div id="compareResults"></div>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>

        // Initialize file import handlers
        handleFileImport('polygonBoundaryInput', 'polygonBoundaryStatus', { requireSinglePolygon: true, fileType: 'geojson' });
        handleFileImport('featuresFileInput', 'featuresFileStatus');

        function handleFileImport(inputId, statusId, options = {}) {
            document.getElementById(inputId).addEventListener('change', function(event) {
                const file = event.target.files[0];
                const statusDiv = document.getElementById(statusId);
                if (!file) {
                    statusDiv.textContent = '';
                    if (inputId === 'featuresFileInput') document.getElementById('featuresCSVColumnSelector').innerHTML = '';
                    return;
                }
                let fileType = options.fileType;
                if (inputId === 'featuresFileInput') {
                    fileType = document.getElementById('featuresFileTypeSelect').value;
                }
                if (fileType === 'geojson') {
                    const validTypes = [
                        'application/geo+json', 'application/json', 'application/octet-stream'
                    ];
                    const ext = file.name.split('.').pop().toLowerCase();
                    if (!validTypes.includes(file.type) && ext !== 'geojson' && ext !== 'json') {
                        statusDiv.style.color = 'red';
                        statusDiv.textContent = 'Please select a valid GeoJSON file (.geojson or .json).';
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const json = JSON.parse(e.target.result);
                            if (options.requireSinglePolygon) {
                                if (!isSinglePolygonOrMultiPolygonFeatureOrCollection(json)) {
                                    statusDiv.style.color = 'red';
                                    statusDiv.textContent = 'File must be a single Polygon or MultiPolygon Feature, or a FeatureCollection with one such Feature.';
                                    return;
                                }
                            } else {
                                if (!isValidGeoJSON(json)) {
                                    statusDiv.style.color = 'red';
                                    statusDiv.textContent = 'The file is not a valid GeoJSON object.';
                                    return;
                                }
                            }
                            statusDiv.style.color = '#006400';
                            statusDiv.textContent = `GeoJSON imported and validated successfully!`;
                            if (inputId === 'polygonBoundaryInput') {
                                setPolygonBoundaryGeoJSON(json);
                            } else if (inputId === 'featuresFileInput') {
                                setFeaturesGeoJSON(json);
                                featuresCSV = null;
                            }
                            console.log(`Imported GeoJSON (${inputId}):`, json);
                        } catch (err) {
                            statusDiv.style.color = 'red';
                            statusDiv.textContent = 'Invalid JSON file.';
                        }
                    };
                    reader.readAsText(file);
                } else if (fileType === 'csv') {
                    const ext = file.name.split('.').pop().toLowerCase();
                    if (file.type !== 'text/csv' && ext !== 'csv') {
                        statusDiv.style.color = 'red';
                        statusDiv.textContent = 'Please select a valid CSV file (.csv).';
                        document.getElementById('featuresCSVColumnSelector').innerHTML = '';
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const text = e.target.result;
                        if (!text.includes(',') || text.split('\n').length < 2) {
                            statusDiv.style.color = 'red';
                            statusDiv.textContent = 'Invalid CSV file.';
                            document.getElementById('featuresCSVColumnSelector').innerHTML = '';
                            return;
                        }
                        featuresCSV = text;
                        featuresGeoJSON = null;
                        const { headers, rows } = parseCSV(text);
                        featuresCSVHeaders = headers;
                        statusDiv.style.color = '#006400';
                        statusDiv.textContent = 'CSV imported! Please select the geometry column.';
                        promptForGeometryColumn(headers, (geometryColumn, statusDiv) => {
                            const geojson = convertCSVtoGeoJSON(rows, geometryColumn);
                            if (!geojson.features.length) {
                                statusDiv.style.color = 'red';
                                statusDiv.textContent = 'No valid GeoJSON geometries found in the selected column.';
                                return;
                            }
                            setFeaturesGeoJSON(geojson);
                            statusDiv.style.color = '#006400';
                            statusDiv.textContent = `CSV converted to GeoJSON successfully!`;
                            document.getElementById('featuresCSVColumnSelector').innerHTML = '';
                            console.log('Converted GeoJSON from CSV:', geojson);
                        });
                    };
                    reader.readAsText(file);
                }
            });
        }

        // --- Utility functions for GeoJSON validation ---

        /**
         * Checks if the object is a valid GeoJSON object.
         */
        function isValidGeoJSON(obj) {
            if (!obj || typeof obj !== 'object' || !obj.type) return false;
            const geoTypes = [
                'Feature', 'FeatureCollection', 'Point', 'LineString', 'Polygon',
                'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'
            ];
            if (!geoTypes.includes(obj.type)) return false;
            if (obj.type === 'FeatureCollection' && !Array.isArray(obj.features)) return false;
            if (obj.type === 'Feature' && !obj.geometry) return false;
            return true;
        }

        /**
         * Checks if the object is a single Feature or FeatureCollection with one Feature,
         * and the geometry is Polygon or MultiPolygon.
         */
        function isSinglePolygonOrMultiPolygonFeatureOrCollection(obj) {
            if (
                obj && obj.type === 'Feature' &&
                obj.geometry &&
                (obj.geometry.type === 'Polygon' || obj.geometry.type === 'MultiPolygon')
            ) {
                return true;
            }
            if (
                obj && obj.type === 'FeatureCollection' &&
                Array.isArray(obj.features) &&
                obj.features.length === 1 &&
                obj.features[0].type === 'Feature' &&
                obj.features[0].geometry &&
                (obj.features[0].geometry.type === 'Polygon' || obj.features[0].geometry.type === 'MultiPolygon')
            ) {
                return true;
            }
            return false;
        }

        // Patch import logic to update compare button after import/conversion
        function setPolygonBoundaryGeoJSON(val) { polygonBoundaryGeoJSON = val; updateCompareButton(); }
        function setFeaturesGeoJSON(val) { featuresGeoJSON = val; updateCompareButton(); }
        // Use these setters in import logic

        // --- Main logic for handling file imports ---

        // Store imported GeoJSON/CSV objects for later use
        let polygonBoundaryGeoJSON = null;
        let featuresGeoJSON = null;
        let featuresCSV = null;
        let featuresCSVHeaders = [];
        // Store the features for export functionality
        let withinFeatures = [];
        let outsideFeatures = [];

        /**
         * Utility to parse CSV text into an array of objects using PapaParse.
         * Assumes first line is header.
         */
        function parseCSV(text) {
            const result = Papa.parse(text, { header: true, skipEmptyLines: true });
            return { headers: result.meta.fields, rows: result.data };
        }

        /**
         * Prompts the user to select the geometry column from CSV headers.
         */
        function promptForGeometryColumn(headers, onSelect) {
            const selectorDiv = document.getElementById('featuresCSVColumnSelector');
            selectorDiv.innerHTML = '';
            const label = document.createElement('label');
            label.textContent = 'Select geometry column:';
            label.style.marginRight = '8px';
            const select = document.createElement('select');
            select.id = 'geometryColumnSelect2';
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '-- Select geometry column --';
            select.appendChild(defaultOption);
            headers.forEach(h => {
                const option = document.createElement('option');
                option.value = h;
                option.textContent = h;
                select.appendChild(option);
            });
            const button = document.createElement('button');
            button.textContent = 'Convert to GeoJSON';
            button.style.marginLeft = '10px';
            button.disabled = true;
            // Enable button only when a valid column is selected
            select.addEventListener('change', function() {
                button.disabled = !select.value;
            });
            button.onclick = () => {
                const statusDiv = document.getElementById('featuresFileStatus');
                if (!select.value) {
                    statusDiv.style.color = 'red';
                    statusDiv.textContent = 'Please select a geometry column before converting.';
                    select.style.borderColor = 'red';
                    return;
                }
                select.style.borderColor = '';
                onSelect(select.value, statusDiv);
            };
            selectorDiv.appendChild(label);
            selectorDiv.appendChild(select);
            selectorDiv.appendChild(button);
        }

        /**
         * Converts CSV rows to a GeoJSON FeatureCollection using the selected geometry column.
         * Now validates that at least one valid geometry exists.
         */
        function convertCSVtoGeoJSON(rows, geometryColumn) {
            const features = rows.map(row => {
                let geometry = null;
                try {
                    geometry = JSON.parse(row[geometryColumn]);
                } catch (e) {
                    geometry = null;
                }
                const properties = { ...row };
                delete properties[geometryColumn];
                return {
                    type: 'Feature',
                    geometry,
                    properties
                };
            }).filter(f => f.geometry && f.geometry.type);
            return {
                type: 'FeatureCollection',
                features
            };
        }

        // Enable/disable compare button based on import status
        function updateCompareButton() {
            const btn = document.getElementById('compareBtn');
            btn.disabled = !(polygonBoundaryGeoJSON && featuresGeoJSON && featuresGeoJSON.features && featuresGeoJSON.features.length);
        }

        // Patch import logic to update compare button
        Object.defineProperty(window, 'polygonBoundaryGeoJSON', {
            set(val) { polygonBoundaryGeoJSON = val; updateCompareButton(); },
            get() { return polygonBoundaryGeoJSON; }
        });
        Object.defineProperty(window, 'featuresGeoJSON', {
            set(val) { featuresGeoJSON = val; updateCompareButton(); },
            get() { return featuresGeoJSON; }
        });
        // Also call updateCompareButton after conversion
        // (for direct assignment in code)

        // --- Comparison logic ---
        document.getElementById('compareBtn').addEventListener('click', function() {
            const resultsDiv = document.getElementById('compareResults');
            resultsDiv.innerHTML = '';
            if (!polygonBoundaryGeoJSON || !featuresGeoJSON || !featuresGeoJSON.features || !featuresGeoJSON.features.length) {
                resultsDiv.style.color = 'red';
                resultsDiv.textContent = 'Both files must be imported and valid before comparison.';
                return;
            }
            // Get the polygon geometry from file 1
            let polygon = polygonBoundaryGeoJSON;
            if (polygon.type === 'FeatureCollection') polygon = polygon.features[0];
            const polyGeom = polygon.geometry;
            // Compare each feature in file 2
            withinFeatures = [];
            outsideFeatures = [];
            featuresGeoJSON.features.forEach((feat, idx) => {
                try {
                    if (feat.geometry && (feat.geometry.type === 'Point' || feat.geometry.type === 'Polygon' || feat.geometry.type === 'MultiPolygon' || feat.geometry.type === 'LineString' || feat.geometry.type === 'MultiLineString')) {
                        if (turf.booleanWithin(feat, polygon)) {
                            withinFeatures.push({ idx, feat });
                        } else {
                            outsideFeatures.push({ idx, feat });
                        }
                    } else {
                        outsideFeatures.push({ idx, feat });
                    }
                } catch (e) {
                    outsideFeatures.push({ idx, feat });
                }
            });
            // Output summary
            resultsDiv.style.color = '#333';
            resultsDiv.innerHTML = `<b>Comparison Results:</b><br>
                <span style='color:green;'>${withinFeatures.length}</span> out of <span style='color:blue;'>${featuresGeoJSON.features.length}</span> features are <b>within</b> the polygon.<br>`;
            if (withinFeatures.length) {
                resultsDiv.innerHTML += `<details><summary>Show features within</summary><ol>${withinFeatures.map(f => `<li>Feature #${f.idx+1} (${f.feat.geometry.type})</li>`).join('')}</ol></details>`;
                resultsDiv.innerHTML += `<div class="export-buttons">
                    <button class="export-btn" id="export-within-geojson">Export Within (GeoJSON)</button>
                    <button class="export-btn" id="export-within-csv">Export Within (CSV)</button>
                </div>`;
            }
            if (outsideFeatures.length) {
                resultsDiv.innerHTML += `<details><summary>Show features outside</summary><ol>${outsideFeatures.map(f => `<li>Feature #${f.idx+1} (${f.feat.geometry ? f.feat.geometry.type : 'No geometry'})</li>`).join('')}</ol></details>`;
                resultsDiv.innerHTML += `<div class="export-buttons">
                    <button class="export-btn" id="export-outside-geojson">Export Outside (GeoJSON)</button>
                    <button class="export-btn" id="export-outside-csv">Export Outside (CSV)</button>
                </div>`;
            }
            
            // Add event listeners for export buttons
            if (withinFeatures.length) {
                document.getElementById('export-within-geojson').addEventListener('click', function() {
                    exportFeatures(withinFeatures, 'within', 'geojson');
                });
                document.getElementById('export-within-csv').addEventListener('click', function() {
                    exportFeatures(withinFeatures, 'within', 'csv');
                });
            }
            
            if (outsideFeatures.length) {
                document.getElementById('export-outside-geojson').addEventListener('click', function() {
                    exportFeatures(outsideFeatures, 'outside', 'geojson');
                });
                document.getElementById('export-outside-csv').addEventListener('click', function() {
                    exportFeatures(outsideFeatures, 'outside', 'csv');
                });
            }
        });

        /**
         * Export features as GeoJSON or CSV file
         * @param {Array} features - Array of feature objects with idx and feat properties
         * @param {string} type - Either 'within' or 'outside'
         * @param {string} format - Either 'geojson' or 'csv'
         */
        function exportFeatures(features, type, format) {
            if (!features || !features.length) return;

            // Extract just the feature objects, not the indices
            const extractedFeatures = features.map(item => item.feat);
            
            let content, filename, mime;
            
            if (format === 'geojson') {
                // Create a GeoJSON FeatureCollection
                const geojson = {
                    type: 'FeatureCollection',
                    features: extractedFeatures
                };
                content = JSON.stringify(geojson, null, 2);
                filename = `features_${type}_polygon.geojson`;
                mime = 'application/geo+json';
            } else {
                // Convert to CSV
                // First get all unique property keys
                const propertyKeys = new Set();
                extractedFeatures.forEach(feat => {
                    if (feat.properties) {
                        Object.keys(feat.properties).forEach(key => propertyKeys.add(key));
                    }
                });
                
                // Add geometry column
                propertyKeys.add('geometry');
                
                // Create CSV header row
                const headers = Array.from(propertyKeys);
                let csv = headers.join(',') + '\n';
                
                // Add rows for each feature
                extractedFeatures.forEach(feat => {
                    const row = headers.map(key => {
                        if (key === 'geometry') {
                            return JSON.stringify(feat.geometry);
                        } else {
                            const val = feat.properties && feat.properties[key] !== undefined ? 
                                feat.properties[key] : '';
                            // Handle values that might contain commas by quoting them
                            return typeof val === 'string' && (val.includes(',') || val.includes('"')) ?
                                `"${val.replace(/"/g, '""')}"` : val;
                        }
                    });
                    csv += row.join(',') + '\n';
                });
                
                content = csv;
                filename = `features_${type}_polygon.csv`;
                mime = 'text/csv';
            }
            
            // Create and trigger download
            const blob = new Blob([content], { type: mime });
            const link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>